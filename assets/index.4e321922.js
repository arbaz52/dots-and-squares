import{c as e}from"./vendor.f3e23d81.js";!function(e=".",t="__import__"){try{self[t]=new Function("u","return import(u)")}catch(s){const i=new URL(e,location),n=e=>{URL.revokeObjectURL(e.src),e.remove()};self[t]=e=>new Promise(((s,o)=>{const h=new URL(e,i);if(self[t].moduleMap[h])return s(self[t].moduleMap[h]);const l=new Blob([`import * as m from '${h}';`,`${t}.moduleMap['${h}']=m;`],{type:"text/javascript"}),r=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(l),onerror(){o(new Error(`Failed to import: ${e}`)),n(r)},onload(){s(self[t].moduleMap[h]),n(r)}});document.head.appendChild(r)})),self[t].moduleMap={}}}("/dots-and-squares/assets/");class t{constructor(e,t){this.northWest=e,this.player=t}}class s{constructor(e,t,s="green"){this.p1=e,this.p2=t,this.player=s}getDirection(){const e=this.p1.x-this.p2.x,t=this.p1.y-this.p2.y;return 1==t?"north":-1==e?"east":-1==t?"south":1==e?"west":void 0}isValid(){return Math.abs(this.p1.x-this.p2.x)+Math.abs(this.p1.y-this.p2.y)===1}isEqual(e){return this.p1.isEqual(e.p1)&&this.p2.isEqual(e.p2)||this.p2.isEqual(e.p1)&&this.p1.isEqual(e.p2)}}class i{constructor(e,t){this.x=e,this.y=t}static getDistance(e,t){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}isEqual(e){return this.x===e.x&&this.y===e.y}}const n=document.getElementById("canvas"),o=n.getContext("2d");new class{constructor(e,t,s=6,i=48,n="green"){this.canvas=e,this.ctx=t,this.cells=s,this.padding=i,this.currentPlayer=n,this.lines=[],this.boxes=[]}resize(){const{canvas:e,ctx:t}=this;e.width=window.innerWidth,e.height=window.innerWidth,t.beginPath(),t.fillStyle="black",t.rect(0,0,e.width,e.height),t.fill()}getCellSize(){return(this.canvas.width-2*this.padding)/this.cells}getCoord(e,t){const s=this.getCellSize(),n=e*s+this.padding,o=t*s+this.padding;return new i(n,o)}getClosestPointTo(e,t){const s=this.getCellSize(),n=(e-this.padding)/s,o=(t-this.padding)/s;return new i(Math.round(n),Math.round(o))}_drawCells(){const{ctx:e}=this;for(let t=0;t<=this.cells;t++)for(let s=0;s<=this.cells;s++){const{x:i,y:n}=this.getCoord(s,t);e.beginPath(),e.fillStyle="white",e.arc(i,n,4,0,2*Math.PI),e.fill(),this.closest&&this.closest.x===s&&this.closest.y===t&&(e.beginPath(),e.fillStyle="red",e.arc(i,n,8,0,2*Math.PI),e.fill())}}_drawLines(){const{ctx:t}=this;for(let{p1:e,p2:s,player:i}of this.lines){const n=this.getCoord(e.x,e.y),o=this.getCoord(s.x,s.y);t.beginPath(),t.strokeStyle=i,t.lineWidth=4,t.moveTo(n.x,n.y),t.lineTo(o.x,o.y),t.stroke()}if(this.startingPoint&&this.mouse){const s=this.getCoord(this.startingPoint.x,this.startingPoint.y);t.beginPath(),t.strokeStyle=e(.25,this.currentPlayer),t.lineWidth=4,t.moveTo(s.x,s.y),t.lineTo(this.mouse.x,this.mouse.y),t.stroke()}}_drawMouse(){if(!this.mouse)return;const{ctx:e,mouse:{x:t,y:s}}=this;e.beginPath(),e.fillStyle="red",e.arc(t,s,4,0,2*Math.PI),e.fill()}_clear(){const{canvas:e,ctx:t}=this;t.beginPath(),t.fillStyle="black",t.rect(0,0,e.width,e.height),t.fill()}_drawBoxes(){const{ctx:t}=this;for(let{northWest:s,player:i}of this.boxes){const n=this.getCoord(s.x,s.y),o=this.getCellSize();t.beginPath(),t.fillStyle=e(.75,i),t.rect(n.x,n.y,o,o),t.fill()}}draw(){requestAnimationFrame(this.draw.bind(this)),this._clear(),this._drawCells(),this._drawLines(),this._drawMouse(),this._drawBoxes()}handleMouseDown(e){const{clientX:t,clientY:s}=e;this.startingPoint=this.getClosestPointTo(t,s)}getBoxes(e){const n=[],o=e.getDirection();switch(console.debug(o),o){case"north":{const{p1:{x:o,y:h},p1:l,p2:{x:r,y:a},p2:c}=e,u=new s(new i(o+1,h),new i(r+1,a)),d=new s(new i(o-1,h),new i(r-1,a)),w=new s(new i(o+1,h-1),c),g=new s(l,new i(r+1,a+1));if([d,new s(new i(o-1,h-1),c),new s(l,new i(r-1,a+1))].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("west side");const e=new t(new i(r-1,a),this.currentPlayer);n.push(e)}if([u,w,g].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("east side");const e=new t(c,this.currentPlayer);n.push(e)}}break;case"south":{const{p2:{x:o,y:h},p2:l,p1:{x:r,y:a},p1:c}=e,u=new s(new i(o+1,h),new i(r+1,a)),d=new s(new i(o-1,h),new i(r-1,a)),w=new s(new i(o+1,h-1),c),g=new s(l,new i(r+1,a+1));if([d,new s(new i(o-1,h-1),c),new s(l,new i(r-1,a+1))].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("west side");const e=new t(new i(r-1,a),this.currentPlayer);n.push(e)}if([u,w,g].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("east side");const e=new t(c,this.currentPlayer);n.push(e)}}break;case"east":{const{p1:{x:o,y:h},p1:l,p2:{x:r,y:a},p2:c}=e,u=new s(new i(o,h-1),new i(r,a-1)),d=new s(new i(o,h+1),new i(r,a+1)),w=new s(new i(o+1,h-1),c),g=new s(new i(o+1,h+1),c),p=new s(l,new i(r-1,a-1)),y=new s(l,new i(r-1,a+1));if([u,w,p].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("north side");const e=new t(new i(o,h-1),this.currentPlayer);n.push(e)}if([d,g,y].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("south side");const e=new t(new i(o,h),this.currentPlayer);n.push(e)}}break;case"west":{const{p2:{x:o,y:h},p2:l,p1:{x:r,y:a},p1:c}=e,u=new s(new i(o,h-1),new i(r,a-1)),d=new s(new i(o,h+1),new i(r,a+1)),w=new s(new i(o+1,h-1),c),g=new s(new i(o+1,h+1),c),p=new s(l,new i(r-1,a-1)),y=new s(l,new i(r-1,a+1));if([u,w,p].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("north side");const e=new t(new i(o,h-1),this.currentPlayer);n.push(e)}if([d,g,y].every((e=>this.lines.filter((t=>t.isEqual(e))).length>0))){console.debug("south side");const e=new t(new i(o,h),this.currentPlayer);n.push(e)}}break;default:console.error("direction undefined")}return this.boxes.push(...n),n}togglePlayer(){this.currentPlayer="green"===this.currentPlayer?"red":"green"}handleMouseUp(e){const{clientX:t,clientY:i}=e;if(this.startingPoint){const e=this.getClosestPointTo(t,i),n=new s(this.startingPoint,e,this.currentPlayer);if(n.isValid()&&!this.lines.some((e=>e.isEqual(n)))){console.debug("adding");const e=this.getBoxes(n).length;this.lines.push(n),0==e&&this.togglePlayer()}}this.startingPoint=void 0}handleMouseMove(e){const{clientX:t,clientY:s}=e;this.mouse||(this.mouse=new i(0,0)),this.mouse.x=t,this.mouse.y=s,this.closest=this.getClosestPointTo(t,s)}handleTouchStart(e){const{touches:t}=e,{clientX:s,clientY:i}=t[0];this.startingPoint=this.getClosestPointTo(s,i)}handleTouchEnd(e){const{changedTouches:t}=e,{clientX:i,clientY:n}=t[0];if(this.startingPoint){const e=this.getClosestPointTo(i,n),t=new s(this.startingPoint,e,this.currentPlayer);if(t.isValid()&&!this.lines.some((e=>e.isEqual(t)))){console.debug("adding");const e=this.getBoxes(t).length;this.lines.push(t),0==e&&this.togglePlayer()}}this.startingPoint=void 0,this.closest=void 0,this.mouse=void 0}handleTouchMove(e){const{touches:t}=e,{clientX:s,clientY:n}=t[0];this.mouse||(this.mouse=new i(0,0)),this.mouse.x=s,this.mouse.y=n,this.closest=this.getClosestPointTo(s,n)}setup(){this.resize(),window.onresize=this.resize.bind(this),this.canvas.onmousedown=this.handleMouseDown.bind(this),this.canvas.onmouseup=this.handleMouseUp.bind(this),this.canvas.ontouchstart=this.handleTouchStart.bind(this),this.canvas.ontouchend=this.handleTouchEnd.bind(this),this.canvas.ontouchmove=this.handleTouchMove.bind(this),this.canvas.onmousemove=this.handleMouseMove.bind(this),this.draw()}}(n,o).setup();
